package main

import (
	"fmt"
	"sync"
)

func main() {

	// Массив чисел
	numbers := [5]int{2, 4, 6, 8, 10}

	/////////////////////////////////////
	// Реализация через sync.WaitGroup //
	/////////////////////////////////////

	// Объявляем экземпляр WaitGroup, чтобы основная горутина не завершилась раньше времени
	wg := sync.WaitGroup{}

	// Вносим длину numbers в счетчик WaitGroup
	wg.Add(len(numbers))

	for _, n := range numbers {
		// Запускаем в горутине анонимную функцию, вычисляющую квадрат числа n и выводящую его в консоль
		go func(n int) {
			fmt.Printf("%d^2 = %d\n", n, n*n)

			// декрементируем счетчик WaitGroup
			wg.Done()
		}(n)
	}

	// ждем, пока счетчик WaitGroup не обнулится
	wg.Wait()

	/////////////////////////////
	// Реализация через каналы //
	/////////////////////////////
	// Создаем буферизированный канал для синхронизации выполнения между горутинами
	// в качестве типа данных для канала используем пустую структуру - 0 byte trick
	doneCh := make(chan struct{}, len(numbers))
	defer close(doneCh)

	for _, n := range numbers {
		// Запускаем в горутине анонимную функцию, вычисляющую квадрат числа n и передающую его в канал
		go func(n int) {
			fmt.Printf("%d^2 = %d\n", n, n*n)
			// запускаем функцию в отдельной горутине
			doneCh <- struct{}{}
		}(n)
	}

	for range numbers {
		<-doneCh
	}

}
